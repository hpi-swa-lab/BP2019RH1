{"type":"Reference","version":"9d267be585297e13aa7dd151536600c8e205ece8","content":"// needed to be able to call functions called with event listener with the context of FreehandDrawer and not the context of the element to which the event listener is bound\nvar boundDraw;\nvar boundSetPosition;\nvar boundOnDrawStop;\n\nimport d3 from 'src/external/d3.v5.js'\nimport ContextMenu from 'src/client/contextmenu.js'\n\n\nimport inside from \"https://lively-kernel.org/lively4/BP2019RH1/src/internal/individuals-as-points/common/npm-point-in-polygon.js\" //absolute path needed, don't ask why\n\nimport FreehandSelection from './freehandSelection.js'\nimport ColorStore from './color-store.js'\nimport { deepCopy } from './utils.js'\n\nexport default class FreehandDrawer {\n  constructor(parentElement, canvas, svg, style = {}) {\n    \n    // parentElement should be a div containing the canvas (on some level)\n    // canvas should lay on top of svg, canvas and svg should always have same extent\n    \n    this.parentElement = parentElement\n    this.canvas = canvas\n    this.svg = svg\n    \n    this.pos = { x: 0, y: 0 }\n    this.transform = {x: 0 , y: 0, k: 1}\n    this.colorstore = new ColorStore()\n    \n    this._initializeContext(canvas, style)\n  \n    this.lastLinePoints = []\n    this.selections = []\n\n    this.listeners = []\n\n    this._registerEventListeners()\n    boundDraw = this._draw.bind(this)\n    boundSetPosition = this._setPosition.bind(this)\n    boundOnDrawStop = this._onDrawStop.bind(this)\n  }\n\n  start() {\n    this.canvas.addEventListener('mousemove', boundDraw, {capture: true})\n    this.canvas.addEventListener('mousedown', boundSetPosition, {capture: true})\n    this.canvas.addEventListener('mouseup', boundOnDrawStop, {capture: true})\n  }\n\n  stop() {\n    this.canvas.removeEventListener('mousemove', boundDraw)\n    this.canvas.removeEventListener('mousedown', boundSetPosition)\n    this.canvas.removeEventListener('mouseup', boundOnDrawStop)\n  }\n \n  addListener(listener) {\n    this.listeners.push(listener)\n  }\n  \n  drawSelections() {\n    let leftPadding = this.canvas.style.paddingLeft ? parseInt(this.canvas.style.paddingLeft) : 0\n    let topPadding = this.canvas.style.paddingTop ? parseInt(this.canvas.style.paddingTop) : 0\n    \n    let selections = this.selections\n    d3.select(this.svg).selectAll(\"polygon\")\n      .filter(function (d){ return !selections.some(selection => selection.color === d.color)})\n      .remove()\n    \n    d3.select(this.svg).selectAll(\"polygon\")\n      .data(this.selections)\n      .enter()\n      .append(\"polygon\")\n      .attr(\"points\",function(d) { \n            return d.linePoints.map(function(d) {\n                return [d.x + leftPadding, d.y + topPadding].join(\",\");\n            }).join(\" \");\n          })\n      .style(\"fill\", function(d) {return d.color})\n      .style(\"fill-opacity\", \"0.3\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-dasharray\", \"5,5\")\n  }\n  \n  applyScaling(factor) {\n    this.selections.forEach(selection => {\n      selection.linePoints = selection.linePoints.map(point => {\n        return {\"x\": point.x * factor.x, \"y\": point.y * factor.y}\n      })  \n    })\n    this.drawSelections()\n  }\n  \n  applyTransform(transform) {\n    this.transform = transform\n    d3.select(this.svg).selectAll(\"polygon\")\n      .attr(\"transform\", transform)\n  }\n  \n  updateStyle(style) {\n    this.ctx.lineWidth = style.lineWidth ? style.lineWidth : this.ctx.lineWidth\n    this.ctx.lineCap = style.lineCap ? style.lineCap : this.ctx.lineCap\n    this.ctx.strokeStyle = style.strokeStyle ? style.strokeStyle : this.ctx.strokeStyle\n  }\n  \n  deleteSelections() {\n    this.selections.forEach(selection => {\n      this._deleteSelection(selection)\n    })\n  }\n  \n  _onDrawStop() {\n    this.lastLinePoints.push({ \"x\": this.pos.x, \"y\": this.pos.y })\n    \n    let newFreehandSelection = new FreehandSelection(this.colorstore.generateRandomHexColor(), deepCopy(this.lastLinePoints))\n    this.selections.push(newFreehandSelection)\n\n    this.listeners.forEach(listener => {\n      listener.freehandSelectionCreated()\n    })\n    \n    this.lastLinePoints = []\n  }\n\n  _setPosition(e) {\n    let position = this._calculateRelativePosition(e) \n        \n    this.pos.x = position.x;\n    this.pos.y = position.y;\n  }\n  \n  _calculateRelativePosition(e) {\n    var rect = e.target.getBoundingClientRect()\n    let paddingLeft = this.canvas.style.paddingLeft ? parseInt(this.canvas.style.paddingLeft) : 0\n    let paddingTop = this.canvas.style.paddingTop ? parseInt(this.canvas.style.paddingTop) : 0\n    var x = e.clientX - rect.left - paddingLeft\n    var y = e.clientY - rect.top - paddingTop\n    \n    // apply tranformation\n    x = (x - this.transform.x) / this.transform.k\n    y = (y - this.transform.y) / this.transform.k\n    \n    return lively.pt(x,y)\n  }\n  \n\n  _draw(e) {\n    // mouse left button and shiftKey must be pressed\n    if (e.buttons !== 1) return\n    if (!e.shiftKey) return\n    \n    this.ctx.save()\n    this.ctx.translate(this.transform.x, this.transform.y)\n    this.ctx.scale(this.transform.k, this.transform.k)\n    \n    this.ctx.beginPath() // begin\n\n    this.ctx.moveTo(this.pos.x, this.pos.y) // from\n\n    this.lastLinePoints.push({ \"x\": this.pos.x, \"y\": this.pos.y })\n\n    this._setPosition(e)\n    this.ctx.lineTo(this.pos.x, this.pos.y) // to\n\n    this.ctx.stroke() // draw it!\n    this.ctx.restore()\n  }\n\n  _clear() {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n  }\n  \n  _initializeContext(canvas, style) {\n    this.ctx = canvas.getContext('2d')\n    this.ctx.lineWidth = style.lineWidth ? style.lineWidth : 1\n    this.ctx.lineCap = style.lineCap ? style.lineCap : 'round'\n    this.ctx.strokeStyle = style.strokeStyle ? style.strokeStyle : \"#000000\"\n  }\n  \n  _deleteSelection(selection) {\n    if (this.selections.includes(selection) ) {\n      this.selections.splice(this.selections.indexOf(selection), 1)\n    }\n    this.listeners.forEach(listener => listener.freehandSelectionDeleted(selection))\n  }\n  \n  _registerEventListeners() {\n    this.canvas.addEventListener(\"contextmenu\", (evt) => {\n      let currentSelection = this._findSelectionFromPosition(evt)\n      if (currentSelection) {\n        evt.stopPropagation()\n        evt.preventDefault()\n        let selectionSVG = this._getSVGElementFromSelection(currentSelection)\n        this._openSelectionMenu(evt, currentSelection, selectionSVG)\n      }\n    })\n  }\n  \n  _findSelectionFromPosition(evt) {\n    let result = false\n    let position = this._calculateRelativePosition(evt)\n    this.selections.forEach(selection => {\n      let linePointsArray = selection.linePoints.map(point => [point.x, point.y])\n      if (inside([position.x, position.y], linePointsArray)) {\n        result = selection\n      } \n    })\n    return result\n  }\n  \n  _getSVGElementFromSelection(selection) {\n    var d3Selection = d3.select(this.svg).selectAll(\"polygon\").filter(function(svg) {\n      return svg.color === selection.color;\n    })\n    \n    // happily assuming that we always have just one corresponding selectionElement \n    // (which given the usage of color as a kinda identifier should be fine)\n    if (d3Selection._groups.length >= 1) return d3Selection._groups[0][0] \n  }\n  \n  async _openSelectionMenu(evt, selection, selectionSVG) {\n    const menuItems = [\n      ['Create new visualization from selection', () => {\n        this.listeners.forEach(listener => listener.freehandSelectionOnContextMenu(evt, selection, selectionSVG))\n      }],\n      ['Delete selection', () => this._deleteSelection(selection)]\n    ]\n    const menu = await ContextMenu.openIn(document.body, evt, this.canvas, document.body,  menuItems)\n  }\n}"}