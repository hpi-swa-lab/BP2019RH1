{"type":"Reference","version":"44b6d8b1504f15a9227d0e947c9630ac6fbf2a4d","content":"import { assertListenerInterface } from \"../src/internal/individuals-as-points/common/interfaces.js\"\nimport { KenyaMap, SomaliaMap } from \"../src/internal/individuals-as-points/map/map.js\"\n\nimport Morph from \"src/components/widgets/lively-morph.js\"\nimport d3 from 'src/external/d3.v5.js'\n\nimport FreehandDrawer from '../src/internal/individuals-as-points/common/drawFreehand.js'\nimport inside from \"../src/internal/individuals-as-points/common/npm-point-in-polygon.js\"\n\nimport { SelectActionType, InspectActionType, FilterActionType, ColorActionType } from '../src/internal/individuals-as-points/common/actions.js'\n\nconst INITIAL_POINT_SIZE = 5\n\nexport default class Bp2019MapWidget extends Morph {\n  async initialize() {\n    var iamReady \n    this.ready = new Promise( resolve => {\n      iamReady = resolve\n    })\n    this.listeners = []\n    this.name = \"bp2019-map-widget\"\n    this.currentMap\n    this.drawingCanvas = this.get(\"#bp2019-map-widget-drawing-canvas\")\n    this.uniquePolygonCanvas = this.get(\"#bp2019-map-widget-unique-polygon-canvas\")\n    this.uniqueIndividualCanvas = this.get(\"#bp2019-map-widget-unique-individual-canvas\")\n    this.canvasWindow = this.get(\"#bp2019-map-widget-canvas-container\")\n    this.freehandSelectionSVG = this.get(\"#bp2019-map-widget-free-hand-selection-svg\")\n    this.controlWidget = this.get(\"bp2019-map-control-widget\")\n    this.controlPanelContainer = this.get(\"#map-control-widget-container\")\n    this.controlWidget.addSizeListener(this)\n    this.collapsed = false\n    this.strokeStyle = false\n    \n    this.currentActions = {}\n    \n    // freehand drawCanvas the size of canvas-window\n    this.drawer = new FreehandDrawer(this.canvasWindow, this.drawingCanvas, this.freehandSelectionSVG)\n    this.drawer.addListener(this)\n        \n    iamReady()\n  }\n  \n  attachedCallback() {\n    // here goes checking for windows stuff\n  }\n  \n  detachedCallback() {\n\n  }\n                                            \n  // ------------------------------------------\n  // Public Methods\n  // ------------------------------------------\n  // *** Interface to application ***\n  \n  \n  setStrokeStyle(strokeStyle) {\n    this.strokeStyle = strokeStyle\n  }\n  \n  setGeoData(geoData) {\n    this.geoData = geoData.data\n  }\n  \n  setContainerType(type) {\n    this.containerType = type\n  }\n  \n  updateStrokeStyle(strokeStyle) {\n    this.strokeStyle = strokeStyle\n    this.currentMap.updateStrokeStyle(this.strokeStyle)\n  }\n  \n  onSizeChange(collapsed) {\n    this.collapsed = collapsed\n    this.setExtent(this.extent)\n  }\n  \n  setDataProcessor(dataProcessor) {\n    this.dataProcessor = dataProcessor  \n    this._propagateDataProcessor()\n  }\n  \n  setColorStore(colorStore) {\n    this.colorStore = colorStore\n  }\n  \n  getData() {\n    return this.individuals\n  }\n  \n  async setData(individuals) {\n    this.drawer.deleteSelections()\n    let currentExtent = this.extent\n    if (this.currentMap) {\n      this._setMapSize({x: 1000, y: 1000})\n    }\n    this.individuals = individuals\n    await this._initializeWithData()\n    this.setExtent(currentExtent)\n  }\n  \n  setExtent(extent) {\n    this.extent = extent\n    if (this.collapsed) {\n      if (this.containerType === \"pane\") {\n        lively.setExtent(this.canvasWindow, lively.pt(extent.x, extent.y))\n        this.controlWidget.setExtent(lively.pt(45, extent.y))\n        this.setLocalControls()\n      } else {\n        lively.setExtent(this.canvasWindow, lively.pt(extent.x - 50, extent.y))\n        this.controlWidget.setExtent(lively.pt(45, extent.y))\n      }\n      \n    } else {\n      if (this.containerType === \"pane\") {\n        lively.setExtent(this.canvasWindow, lively.pt(extent.x, extent.y))\n        this.controlWidget.setExtent(lively.pt(200, extent.y))\n        this.setLocalControls()\n      } else {\n        lively.setExtent(this.canvasWindow, lively.pt(extent.x * 0.73, extent.y))\n        this.controlWidget.setExtent(lively.pt(extent.x * 0.20, extent.y))\n      }\n    }\n    \n    let currentCanvasExtent = lively.getExtent(this.canvasWindow)\n    d3.select(this.freehandSelectionSVG)\n      .attr(\"width\", currentCanvasExtent.x + \"px\")\n      .attr(\"height\", currentCanvasExtent.y + \"px\")\n\n    if (this.currentMap) { // should be removed\n      // refactor into setter in map\n      this._setMapSize(currentCanvasExtent)\n      this.currentMap.updateZoom()\n    }\n  }\n  \n  async activate() {\n    // should be removed\n    await this.ready\n    if (this.currentMap) {\n      this.currentMap.updateZoom()\n    }\n  }\n  \n  // *** Interface to control menu ***\n  \n  async applyAction(action){\n    this._dispatchAction(action)   \n  }\n  \n  addListener(listener) {\n    assertListenerInterface(listener)\n    this.listeners.push(listener)\n  }\n  \n  freehandSelectionCreated() {\n    this.currentMap.draw()\n    this.drawer.drawSelections()\n    this.drawer.applyTransform(this.currentMap.zoomer.transform)\n  }\n  \n  freehandSelectionDeleted(selection) {\n    this.currentMap.draw()\n    this.drawer.drawSelections()\n    this.drawer.applyTransform(this.currentMap.zoomer.transform)\n    \n    this.dispatchEvent(new CustomEvent(\"freehand-selection-deleted\", {\n      detail: {\n        selection: selection\n      },\n      bubbles: true\n    }))\n  }\n  \n  freehandSelectionOnContextMenu(evt, selection, selectionSVG) {\n    let linePointsArray = selection.linePoints.map(point => [point.x, point.y])\n    let selectedIndividuals = this.individuals.filter(point => inside([point.drawing.position.x, point.drawing.position.y], linePointsArray))\n    \n    this.dispatchEvent(new CustomEvent(\"freehand-selection-contextmenu\", {\n      detail: {\n        freehandSelectionSVGElement: selectionSVG,\n        clientX: evt.clientX,\n        clientY: evt.clientY,\n        individualsSelection: {selectedIndividuals: selectedIndividuals, selectionColor: selection.color}\n      },\n      bubbles: true\n    }))\n  }\n  \n  setLocalControls() {\n    this.unsetLocalControls()\n    \n    var myWindow = lively.findWindow(this)\n    if (myWindow.isWindow) {\n      myWindow.get(\".window-content\").style.overflow = \"visible\"\n    }\n    \n    this.controlPanelContainer.style.display = \"block\"\n    \n    let parentPosition = lively.getGlobalPosition(this)\n    \n    lively.setGlobalPosition(\n      this.controlPanelContainer, \n      parentPosition.addPt(lively.pt(lively.getExtent(this.parentElement).x, 0))\n    )\n\n    this.controlPanelContainer.style.zIndex = 20000\n  }\n  \n  unsetLocalControls() {\n    this.controlPanelContainer.style.display = \"none\"\n  }\n\n  // ------------------------------------------\n  // Private Methods\n  // ------------------------------------------\n  \n  _setMapSize(size){\n    this.currentMap.width = size.x\n    this.currentMap.height = size.y\n    this.drawingCanvas.width = size.x\n    this.drawingCanvas.height = size.y\n    this.uniquePolygonCanvas.width = size.x\n    this.uniquePolygonCanvas.height = size.y\n    this.uniqueIndividualCanvas.width = size.x\n    this.uniqueIndividualCanvas.height = size.y    \n  }\n  \n  _addEventListenersForSelection() {\n    this.drawer.start()\n  }\n  \n  _removeEventListenersForSelection() {\n    this.drawer.stop()\n  }\n  \n  _addEventListenersForNavigation() {\n    this.currentMap.addEventListenersForNavigation()\n  }\n  \n  _removeEventListenersForNavigation() {\n    this.currentMap.removeEventListenersForNavigation()\n  }\n  \n  _addShiftKeyEventListener() {\n    // d3's zooming interaction which is used for navigating consumes all of it's used events, which are the same events required for the selection interaction\n    \n    this.drawingCanvas.setAttribute(\"tabindex\", 0) //necessary for the ability of the canvas to receive key events\n    this.drawingCanvas.addEventListener(\"keydown\", (event) => {\n      if (event.key == \"Shift\") {\n        this._addEventListenersForSelection()\n        this._removeEventListenersForNavigation()\n      }\n    })\n    this.drawingCanvas.addEventListener(\"keyup\", (event) => {\n      if (event.key == \"Shift\") {\n        this._addEventListenersForNavigation()\n        this._removeEventListenersForSelection()\n      }\n    })\n  } \n  \n  _propagateDataProcessor() {\n    this.controlWidget.setDataProcessor(this.dataProcessor)  \n  }\n  \n  async _initializeWithData() {\n    this.controlWidget = this._registerControlWidget()\n    this.districtTooltipDiv = this.controlWidget.getDistrictTooltip()\n    \n    await this._buildMap()\n    \n    this._addShiftKeyEventListener()\n    this._addEventListenersForNavigation()\n  }\n  \n  _registerControlWidget() {\n    let controlWidget = this.get(\"#bp2019-map-control-widget\")\n    controlWidget.addListener(this)\n    controlWidget.initializeAfterDataFetch()\n    \n    return controlWidget\n  }\n  \n  _applyActionToListeners(action){\n    this.listeners.forEach((listener) => {\n      listener.applyAction(action);\n    })\n  }\n  \n  async _buildMap() {\n    if (this.currentMap) {\n      this.currentMap.clear()\n    }\n    switch(this.dataProcessor.datasetName) {\n      case 'Somalia':\n        this.currentMap = new SomaliaMap(this, INITIAL_POINT_SIZE)\n        break\n      case 'Kenya':\n        this.currentMap = new KenyaMap(this, INITIAL_POINT_SIZE)\n        break\n      default:\n        throw new Error(\"this dataset is not supported\")\n    }\n    \n    this._initializeCurrentMap()\n    await this.currentMap.create(this.individuals)\n    \n    this.currentMap.setStrokeStyle(this.strokeStyle)\n  }\n  \n  _initializeCurrentMap() {\n    this.currentMap.setDataProcessor(this.dataProcessor)\n    this.currentMap.setColorStore(this.colorStore)\n    this.currentMap.setGeoData(this.geoData)\n  }\n  \n  _dispatchAction(action) {\n    switch(action.getType()) {\n      case (ColorActionType):\n        this._handleColorAction(action)\n        break\n      case (InspectActionType):\n        this._handleInspectAction(action)\n        break\n      case (SelectActionType):\n        this._handleSelectAction(action)\n        break\n      case (FilterActionType):\n        this._handleFilterAction(action)\n        break\n      default:\n        this._handleNotSupportedAction(action)\n     }\n  }\n  \n  _handleColorAction(colorAction) {\n    colorAction.runOn(this.individuals)  \n    this.currentMap.draw()\n  }\n  \n  _handleInspectAction(action) {\n    this.currentActions[\"inspect\"] = action\n    action.runOn(this.individuals)\n    this.currentMap.individualClicker.deselectSelectedIndividual()\n    if (!action.selection) {\n      this.currentMap.individualClicker.selectIndividual(null)\n    } else {\n      let individual = this._getIndividualById(action.selection.id)\n      this.currentMap.individualClicker.selectIndividual(individual)\n    }\n    \n    this.currentMap.draw()\n  }\n  \n  _handleFilterAction(action){\n    let filteredIndividuals = action.runOn(this.individuals)\n    if (!filteredIndividuals.includes(this.currentMap.dataHandler.selectedIndividual)) {\n      this.currentMap.individualClicker.deselectSelectedIndividual()\n    }\n    \n    this.currentMap.updateIndividuals(filteredIndividuals)\n  }\n  \n  _handleSelectAction(action) {\n    action.runOn(this.individuals)\n    this.currentMap.draw()\n  }\n  \n  _handleFreeHandSelection(linePoints, event) {\n    let zoomLevel = this.currentMap.zoomer.currentZoomLevel\n    let linePointsArray = linePoints.map(point => [point.x / zoomLevel, point.y / zoomLevel])\n    let selectedPoints = this.individuals.filter(point => inside([point.drawing.position.x, point.drawing.position.y], linePointsArray))\n    \n    this.dispatchEvent(new CustomEvent(\"selection-contextmenu\", {\n      detail: {\n        selectedPoints: selectedPoints,\n        clientX: event.clientX,\n        clientY: event.clientY,\n        selectionColor: \"CadetBlue\"\n      },\n      bubbles: true\n    }))\n  }\n  \n  _handleNotSupportedAction(action) {}\n  \n  _getIndividualById(id) {\n    for (let i = 0; i < this.individuals.length; i++) {\n      if (this.individuals[i].id === id) {\n        return this.individuals[i]\n      }\n    }\n  }\n\n}"}