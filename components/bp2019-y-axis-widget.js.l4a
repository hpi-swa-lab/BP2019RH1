{"type":"Reference","version":"cf20939219ceb0a496547b7dd82364c9c47cc75f","content":"\"enable aexpr\";\n\nimport d3 from 'src/external/d3.v5.js'\nimport inside from \"https://lively-kernel.org/lively4/BP2019RH1/src/internal/individuals-as-points/common/npm-point-in-polygon.js\"\n\nimport Morph from 'src/components/widgets/lively-morph.js';\nimport FreehandDrawer from '../src/internal/individuals-as-points/common/drawFreehand.js'\n\nimport { getRandomInteger, deepCopy, collapse } from \"../src/internal/individuals-as-points/common/utils.js\"\n\nimport { assertListenerInterface, assertFreeHandSelectionListenerInterface } from \"../src/internal/individuals-as-points/common/interfaces.js\";\n\nimport { \n  InspectAction, \n  SelectAction,\n  FilterAction, \n  ColorAction, \n  GroupAction, \n  NullAction,\n  InspectActionType, \n  SelectActionType,\n  FilterActionType, \n  ColorActionType, \n  GroupActionType, \n  NullActionType\n} from '../src/internal/individuals-as-points/common/actions.js'\n\nvar ctx\nexport default class Bp2019YAxisWidget extends Morph {\n  async initialize() {\n    ctx = this\n    this.name = \"yAxisWidget\"\n    \n    this.dataProcessor = undefined\n    this.colorStore = undefined\n    \n    this.individualIndexByIdentifyingColor = undefined\n    \n    this.listeners = []\n\n    this.container = this.get(\"#y-axis-widget-root-container\")\n    this.canvas = this.get(\"#y-axis-widget-canvas\")\n    this.drawCanvas = this.get(\"#drawCanvas\")\n    this.controlPanel = this.get(\"#control-widget\")\n    this.controlPanel.addSizeListener(this)\n    \n    this.canvas.addEventListener(\"click\", (event) => {this._onCanvasClicked(event)})\n\n    this.canvasPadding = {\"left\": 50, \"top\": 10, \"right\": 10, \"bottom\": 50}\n    \n    this.canvas.style.paddingLeft = this.canvasPadding.left + \"px\"\n    this.canvas.style.paddingTop = this.canvasPadding.top + \"px\"\n    this.canvas.style.paddingRight = this.canvasPadding.right + \"px\"\n    this.canvas.style.paddingBottom = this.canvasPadding.bottom + \"px\"\n    \n    this.drawCanvas.style.paddingLeft = this.canvasPadding.left + \"px\"\n    this.drawCanvas.style.paddingTop = this.canvasPadding.top + \"px\"\n    this.drawCanvas.style.paddingRight = this.canvasPadding.right + \"px\"\n    this.drawCanvas.style.paddingBottom = this.canvasPadding.bottom + \"px\"\n    \n    this.drawer = new FreehandDrawer(this.container, this.drawCanvas)\n    this.drawer.addListener(this)\n    this.drawer.start()\n    \n    this.context = this.canvas.getContext(\"2d\")\n    \n    this.scalesSVG = d3.select(this.get(\"#scales-svg\"))\n    \n    let xAxisGroup = d3.select(this.get(\"#x-axis-group\"))\n    let xScale = d3.scaleBand().padding(0.1)\n    \n    let yAxisGroup = d3.select(this.get(\"#y-axis-group\"))\n    let yScale = d3.scaleBand().padding(0.1)\n    \n    this.groupingInformation = {\n      \"attributes\": {\n        \"x\": \"none\",\n        \"y\": \"none\"\n      },\n      \"axesGroups\": {\n        \"x\": xAxisGroup,\n        \"y\": yAxisGroup\n      },\n      \"scales\": {\n        \"x\": xScale,\n        \"y\": yScale\n      },\n    }\n    \n    this.currentActions = {\n      \"x\": new NullAction(),\n      \"y\": new NullAction(),\n      \"color\": new NullAction(),\n      \"filter\": new NullAction(),\n      \"select\": new NullAction(),\n    }\n        \n    this.controlWidget = this.get(\"#control-widget\")\n    this.controlWidget.addListener(this)\n  }\n  \n  // ------------------------------------------\n  // Public Methods\n  // ------------------------------------------\n  \n  setDataProcessor(dataProcessor) {\n    this.dataProcessor = dataProcessor\n    this._propagateDataProcessor()\n  }\n  \n  setColorStore(colorStore) {\n    this.colorStore = colorStore\n  }\n  \n  async setExtent(extent) {\n    lively.setExtent(this, extent)\n    lively.setExtent(this.container, extent)\n    if (this.data) this._updateExtent()\n  }\n  \n  async setData(data) {\n    this.data = data\n    \n    this.individualIndexByIdentifyingColor = {}\n    this.data.forEach(element => {\n      this.individualIndexByIdentifyingColor[this.colorStore.convertColorObjectToRGBHexString(element.drawing.identifyingColor)] = element.index\n    })\n    \n    this.activate()\n  }\n  \n  getData(data) {\n    return this.data\n  }\n  \n  addListener(listener) {\n    assertListenerInterface(listener)\n    this.listeners.push(listener)\n  }\n  \n  setFreeHandSelectionListener(listener) {\n    assertFreeHandSelectionListenerInterface(listener)\n    this.freeHandSelectionListener = listener\n  }\n  \n  async applyAction(action) {\n    this._dispatchAction(action)\n  }\n  \n  async activate() {\n    this._initializeData()\n    this.originalData = deepCopy(this.data)\n    this.controlWidget.initializeAfterDataFetch()\n    this._initializeAxes()\n    //this._resetAxes()\n    this._runCurrentActions()\n    this._draw()\n  }\n  \n  async stop() {\n    \n  }\n  \n  onSizeChange() {\n    this._updateExtent()\n  }\n  \n  drawFinished(linePoints) {\n    let leftPadding = this.canvasPadding.left\n    let topPadding = this.canvasPadding.top\n\n    \n    this.scalesSVG.selectAll(\"polygon\").remove()\n    \n    this.scalesSVG.selectAll(\"polygon\")\n        .data([linePoints])\n      .enter().append(\"polygon\")\n        .attr(\"points\",function(d) { \n          return d.map(function(d) {\n              return [d.x + leftPadding, d.y + topPadding].join(\",\");\n          }).join(\" \");\n        })\n        .style(\"fill\", \"CadetBlue\")\n        .style(\"fill-opacity\", \"0.3\")\n        .style(\"stroke\", \"black\")\n        .style(\"stroke-dasharray\", \"5,5\")\n        .on(\"contextmenu\", (points) => {\n          let event = d3.event\n          event.preventDefault()\n          event.stopPropagation()\n          this._handleFreeHandSelection(points, event)\n        })\n    \n    //spike draggable borders - draw a draggable Point of each point in polygon\n    // if dragged update linePoints and call updatePolygon\n    /*\n    this.linePoints = linePoints \n    let ctx = this\n    \n    let drag = d3.drag()\n        .on('start', this._dragstarted)\n        .on('drag', this._dragged)\n        .on('end', this._dragended);\n    \n\n    this.scalesSVG.selectAll(\"circle\")\n        .data(linePoints)\n      .enter().append(\"circle\")\n        .attr(\"cx\", function (d) { return d.x + leftPadding})\n        .attr(\"cy\", function (d) { return d.y + topPadding})\n        .attr(\"r\", function (d) { return 3 })\n        .style(\"fill\", \"black\");\n    \n    this.scalesSVG.selectAll(\"circle\")\n      .call(drag)\n  }\n  \n  _dragstarted(d) {\n    d3.select(this).raise().classed('active', true);\n  }\n  \n  _dragged(d) {\n    d3.select(this)\n        .attr('cx', d3.event.x)\n        .attr('cy', d3.event.y)\n    \n    ctx.scalesSVG.select('polygon')\n      .data([ctx.linePoints])\n      .attr(\"points\", function(d) { \n          return d.map(function(d) {\n              return [d.x + ctx.canvasPadding.left, d.y + ctx.canvasPadding.top].join(\",\");\n          }).join(\" \");\n    })\n  }\n  \n  _dragended(d) {\n    d3.select(this).classed('active', false);\n  } */\n    \n  }\n\n  \n  // ------------------------------------------\n  // Private Methods\n  // ------------------------------------------\n  \n  _propagateDataProcessor() {\n    this.controlWidget.setDataProcessor(this.dataProcessor)\n  }\n  \n  _dispatchAction(action) {\n    \n    switch(action.getType()) {\n      case (GroupActionType):\n        this._handleGroupAction(action);\n        break;\n      case (ColorActionType):\n        this._handleColorAction(action);\n        break;\n      case (SelectActionType):\n        this._handleSelectAction(action);\n        break;\n      case (FilterActionType):\n        this._handleFilterAction(action);\n        break;\n      case (InspectActionType):\n        this._handleInspectAction(action)\n        break;\n      case (NullActionType):\n        this._handleNullAction(action)\n        break;\n      default:\n        this._handleNotSupportedAction(action);\n    }\n    \n    this._draw()\n  }\n  \n  _draw() {\n    let context = this.canvas.getContext(\"2d\")\n\n    context.save()\n    \n    let canvasSize = this._getCanvasSize()\n    context.clearRect(0, 0, canvasSize.width, canvasSize.height)\n    \n    this._drawGroupingRectangles(context)\n    \n    this.data.forEach(individual => {\n      const drawingInformation = individual.drawing\n      context.beginPath()\n      context.arc(\n        drawingInformation.currentPosition.x, \n        drawingInformation.currentPosition.y, \n        drawingInformation.currentSize / 2, \n        0, \n        2 * Math.PI, \n        false\n      )\n      context.fillStyle = this.colorStore.convertColorObjectToRGBAHexString(drawingInformation.currentColor)\n      context.fill()\n    })\n\n    context.restore()\n  }\n  \n  _drawWithIdentifyingColors() {\n    const context = this.canvas.getContext(\"2d\")\n    context.save()\n    \n    let canvasSize = this._getCanvasSize()\n    context.clearRect(0, 0, canvasSize.width, canvasSize.height)\n    \n    this.data.forEach(individual => {\n      const drawingInformation = individual.drawing\n      context.beginPath()\n      context.arc(\n        drawingInformation.currentPosition.x, \n        drawingInformation.currentPosition.y, \n        drawingInformation.currentSize / 2, \n        0, \n        2 * Math.PI, \n        false\n      )\n      context.fillStyle = this.colorStore.convertColorObjectToRGBAHexString(drawingInformation.identifyingColor)\n      context.fill()\n    })\n\n    context.restore()\n  }\n  \n  _drawGroupingRectangles(context) {\n    // cases: both attributes -> tiles\n    // one attribute one none -> stripes\n    // one attribute one amount -> bars\n    // both none, both amount, one amount one none -> nothing\n    \n    context.fillStyle = this.colorStore.convertColorObjectToRGBAHexString(this.colorStore.getGroupingRectangleColor())\n    \n    let groupingAttributeX = this.groupingInformation.attributes.x\n    let groupingAttributeY = this.groupingInformation.attributes.y\n    \n    if (groupingAttributeX === \"none\" || groupingAttributeY === \"none\") {\n      if (groupingAttributeX === \"none\" && groupingAttributeY === \"none\") {\n        return\n      } else if (groupingAttributeX === \"amount\" || groupingAttributeY === \"amount\") {\n        return\n      } else {\n        this._drawGroupingStripes(context)\n      }\n    } else if (groupingAttributeX === \"amount\" || groupingAttributeY === \"amount\") {\n      if (groupingAttributeX === \"amount\" && groupingAttributeY === \"amount\") {\n        return\n      } else {\n        this._drawGroupingBars(context)\n      }\n    } else {\n      this._drawGroupingTiles(context)\n    }\n  }\n  \n  _drawGroupingTiles(context) {\n    let xScale = this.groupingInformation.scales.x\n    let yScale = this.groupingInformation.scales.y\n    xScale.domain().forEach(xDomainElement => {\n      yScale.domain().forEach(yDomainElement => {\n        context.fillRect(xScale(xDomainElement), yScale(yDomainElement), xScale.bandwidth(), yScale.bandwidth())\n      })\n    })\n  }\n  \n  _drawGroupingStripes(context) {\n    let groupingAttributeX = this.groupingInformation.attributes.x\n    let groupingAttributeY = this.groupingInformation.attributes.y\n    let xScale = this.groupingInformation.scales.x\n    let yScale = this.groupingInformation.scales.y\n    if (groupingAttributeX !== \"none\") {\n      xScale.domain().forEach(xDomainElement => {\n        context.fillRect(xScale(xDomainElement), 0, xScale.bandwidth(), yScale.range()[0])\n        // the range for y is inverted, thats why we take [0]\n      })\n    } else if (groupingAttributeY !== \"none\") {\n      yScale.domain().forEach(yDomainElement => {\n        context.fillRect(0, yScale(yDomainElement), xScale.range()[1], yScale.bandwidth())\n      })\n    }\n  }\n  \n  _drawGroupingBars(context) {\n    let groupingAttributeX = this.groupingInformation.attributes.x\n    let groupingAttributeY = this.groupingInformation.attributes.y\n    let xScale = this.groupingInformation.scales.x\n    let yScale = this.groupingInformation.scales.y\n    \n    if (groupingAttributeX !== \"amount\") {\n      let amountsByValues = this._getAmountsByValues(this.currentActions[\"x\"].attribute, xScale.domain())\n      xScale.domain().forEach(xDomainElement => {\n        context.fillRect(xScale(xDomainElement), yScale(amountsByValues[xDomainElement]), xScale.bandwidth(), yScale.range()[0] - yScale(amountsByValues[xDomainElement]))\n      })\n    } else if (groupingAttributeY !== \"amount\") {\n      let amountsByValues = this._getAmountsByValues(this.currentActions[\"y\"].attribute, yScale.domain())\n      yScale.domain().forEach(yDomainElement => {\n        context.fillRect(xScale(amountsByValues[yDomainElement]), yScale(yDomainElement), xScale.range()[0] - xScale(amountsByValues[yDomainElement]) , yScale.bandwidth())\n      })\n    }\n  }\n    \n  _initializeData() {\n    this.data.forEach(individual => {\n      let size = individual.drawing.currentSize * 2\n      \n      individual.drawing.currentPosition = {\n        \"x\": getRandomInteger(size, this._getCanvasSize().width - size),\n        \"y\": getRandomInteger(size, this._getCanvasSize().height - size)\n      }\n    })\n  }\n  \n  _initializeAxes() {\n    let xOffset = this.canvasPadding.left\n    let yOffset = this._getCanvasSize().height + this.canvasPadding.top\n    \n    \n    this.groupingInformation.axesGroups.x.attr(\n      'transform', \n      `translate(${xOffset}, ${yOffset})`\n    )\n    this.groupingInformation.axesGroups.y.attr(\n      'transform', \n      `translate(${xOffset}, ${this.canvasPadding.top})`\n    )\n    \n    this.groupingInformation.scales.x.range([0, this._getCanvasSize().width - this.canvasPadding.right])\n    this.groupingInformation.scales.y.range([this._getCanvasSize().height, 0])\n    \n    this._updateAxis(\"x\")\n    this._updateAxis(\"y\")\n  }\n  \n  _rescaleData(oldExtent, newExtent) {\n    this.data.forEach(individual => {\n      individual.drawing.currentPosition.x = individual.drawing.currentPosition.x / oldExtent.x * newExtent.x * 1.0\n      individual.drawing.currentPosition.y = individual.drawing.currentPosition.y / oldExtent.y *  newExtent.y * 1.0\n    })\n  }\n  \n  _resetAxes() {\n    Object.keys(this.groupingInformation.axesGroups).forEach(axisName => {\n      this.resetAxis(axisName)\n    })\n  }\n  \n  _resetAxis(axisName) {\n    this.groupingInformation.attributes[axisName] = \"none\"\n\n    let scale = this.groupingInformation.scales[axisName]\n    scale.domain([])\n    this._updateAxis(axisName)\n  }\n  \n  _updateAxis(axisName) {\n    let scale = this.groupingInformation.scales[axisName]\n\n    let axis\n    if (axisName === \"x\") {\n      axis = d3.axisBottom(scale)\n    } else {\n      axis = d3.axisLeft(scale)\n    }\n\n    this.groupingInformation.axesGroups[axisName].call(axis)\n  }\n  \n  _handleGroupAction(action) {\n    if (action.axis === \"x\") {\n      this.controlWidget.xAxisGroupingWidget.attributeSelect.value = action.attribute\n    } else {\n      this.controlWidget.yAxisGroupingWidget.attributeSelect.value = action.attribute\n    }\n    \n    if (action.attribute === \"none\") {\n      this._handleEmptyGroupingAction(action)\n    } else if (action.attribute === \"amount\") {\n      this._handleGroupingActionAmount(action)\n    } else {\n      this._handleGroupingActionAttribute(action)\n    }\n    \n    this.groupingInformation.attributes[action.axis] = action.attribute\n    this.currentActions[action.axis] = action\n    \n    let otherAxis = action.axis === \"x\" ? \"y\" : \"x\"\n    if (this.groupingInformation.attributes[otherAxis] === \"amount\") {\n      if (this.groupingInformation.attributes[action.axis] !== \"amount\") {\n        this._handleGroupAction(this.currentActions[otherAxis])\n      }\n    }\n  }\n  \n  _handleEmptyGroupingAction(action) {\n    let axisName = action.axis    \n    this._resetAxis(axisName)\n    let canvasSize = this._getCanvasSize()\n    \n    this.data.forEach(individual => {\n      individual.drawing.currentPosition[axisName] = getRandomInteger(0, axisName === \"x\" ? canvasSize.width : canvasSize.height)\n    })\n  }\n  \n  _handleGroupingActionAmount(action) {\n    let axisName = action.axis\n    let otherAxis = axisName === \"x\" ? \"y\" : \"x\"\n    let groupingAttribute = this.groupingInformation.attributes[otherAxis]\n    \n    if (groupingAttribute === \"amount\" || groupingAttribute === \"none\") {\n      lively.notify(\"you cannot get an amount of amounts or randomness\")\n      return\n    }\n    \n    let values = this.dataProcessor.getValuesForAttribute(groupingAttribute)\n    let amountsByValues = this._getAmountsByValues(groupingAttribute, values)\n    let maxValue = 0\n    maxValue = Math.max(...Object.values(amountsByValues))\n    \n    this.groupingInformation.scales[axisName] = d3.scaleLinear().domain([0, maxValue]).range(axisName === \"x\" ? [0, this.canvas.width] : [this.canvas.height, 0])\n    let scale = this.groupingInformation.scales[axisName]\n    \n    this.data.forEach(individual => {\n      let individualValue = this.dataProcessor.getUniqueValueFromIndividual(individual, groupingAttribute)\n      if (axisName === \"x\") {\n        individual.drawing.currentPosition[axisName] = getRandomInteger(0, scale(amountsByValues[individualValue]))\n      } else {\n        individual.drawing.currentPosition[axisName] = getRandomInteger(scale(amountsByValues[individualValue]), this.canvas.height)\n      }\n    })\n    \n    let axis\n    if (axisName === \"x\") {\n      axis = d3.axisBottom(scale)\n    } else {\n      axis = d3.axisLeft(scale)\n    }\n    \n    this.groupingInformation.axesGroups[axisName].call(axis)\n    if (axisName === \"x\") {\n      this.groupingInformation.axesGroups[axisName].selectAll(\"text\")\n          .attr(\"y\", 0)\n          .attr(\"x\", 9)\n          .attr(\"dy\", \".35em\")\n          .attr(\"transform\", \"rotate(90)\")\n          .style(\"text-anchor\", \"start\");\n    }\n  }\n  \n  _handleGroupingActionAttribute(action) {\n    let groupingAttribute = action.attribute\n    let values = this._getValuesForAttribute(groupingAttribute)\n    \n    let axisName = action.axis\n    \n    this.groupingInformation.scales[axisName] = d3.scaleBand().padding(0.1).domain(axisName === \"x\" ? values : values.reverse()).range(axisName === \"x\" ? [0, this.canvas.width] : [this.canvas.height, 0])\n    \n    \n    let scale = this.groupingInformation.scales[axisName]\n    let bandwidth = this.groupingInformation.scales[axisName].bandwidth()\n    \n    this.data.forEach(individual => {\n      let individualValue = this.dataProcessor.getUniqueValueFromIndividual(individual, groupingAttribute)\n      individual.drawing.currentPosition[axisName] = scale(individualValue) + getRandomInteger(0, bandwidth)\n    })\n    \n    let axis\n    if (axisName === \"x\") {\n      axis = d3.axisBottom(scale)\n    } else {\n      axis = d3.axisLeft(scale)\n    }\n    \n    this.groupingInformation.axesGroups[axisName].call(axis)\n    if (axisName === \"x\") {\n      this.groupingInformation.axesGroups[axisName].selectAll(\"text\")\n          .attr(\"y\", 0)\n          .attr(\"x\", 9)\n          .attr(\"dy\", \".35em\")\n          .attr(\"transform\", \"rotate(90)\")\n          .style(\"text-anchor\", \"start\");\n    }\n  }\n       \n  _handleColorAction(action) {\n    this.data = action.runOn(this.data)\n    \n    this.currentActions[\"color\"] = action\n  }\n        \n  _handleFilterAction(action) {\n    this.data = deepCopy(this.originalData)\n    \n    Object.keys(this.currentActions).forEach(key => {\n      if (key !== \"filter\") {\n        this._dispatchAction(this.currentActions[key])\n      }\n    })  \n    this.data = action.runOn(this.data)\n     \n    this.currentActions[\"filter\"] = action\n  }\n        \n  _handleSelectAction(action) {\n    action.runOn(this.data)\n    this.currentActions[\"select\"] = action \n  }\n  \n  _handleInspectAction(action) {\n    action.runOn(this.data)\n  }\n  \n  _handleFreeHandSelection(linePoints, event) {\n    let linePointsArray = linePoints.map(point => [point.x, point.y])\n    let selectedPoints = this.data.filter(point => inside([point.drawing.currentPosition.x, point.drawing.currentPosition.y], linePointsArray))\n    \n    this.dispatchEvent(new CustomEvent(\"selection-contextmenu\", {\n      detail: {\n        selectedPoints: selectedPoints,\n        clientX: event.clientX,\n        clientY: event.clientY,\n        selectionColor: \"CadetBlue\"\n      },\n      bubbles: true\n    }))\n  }\n  \n  _handleNullAction(action) {\n    \n  }\n        \n  _handleNotSupportedAction(action) {\n  \n  }\n  \n  _getAmountsByValues(attribute, values) {\n    let amountsByValues = {}\n    \n    values.forEach(value => {\n      amountsByValues[value] = 0\n    })\n    \n    this.data.forEach(individual => {\n      let individualValue = this.dataProcessor.getUniqueValueFromIndividual(individual, attribute)\n      amountsByValues[individualValue] += 1\n    })\n    return amountsByValues\n  }\n  \n  _getValuesForAttribute(groupingAttribute) {\n    let filterAction = this.currentActions[\"filter\"]\n    let values = []\n    filterAction.filters.forEach(filter => {\n      if (filter.filterAttribute === groupingAttribute) {\n        values = values.concat(filter.filterValues)\n      }\n    })\n    if (values.length <= 0) {\n      return this.dataProcessor.getValuesForAttribute(groupingAttribute)\n    } else {\n      return values\n    }\n  }\n  \n  _onCanvasClicked(event) {\n    this._buildIdentifyingImageData()\n    \n    let clickPosition = this._getCursorPosition(event)\n    let identifyingColor = this._getIdentifyingColor(clickPosition)\n    \n    let individual\n    if (!this._isBackgroundColor(identifyingColor)) {\n      individual = this._getIndividualByIdentifyingColor(identifyingColor)\n    } \n\n    let action = new InspectAction(individual, true, this.dataProcessor, this.colorStore)\n    this.applyAction(action)\n  }\n  \n  _getCursorPosition(event) {\n    let rect = this._getCanvasSize()\n    const x = event.clientX - rect.left\n    const y = event.clientY - rect.top\n    return {\"x\": Math.floor(x), \"y\": Math.floor(y)}\n  }\n  \n  _getIdentifyingColor(position) {\n    let startPosition = (position.y * this.identifyingImageData.width + position.x) * 4\n    \n    let color = {\n      \"r\": this.identifyingImageData.data[startPosition],\n      \"g\": this.identifyingImageData.data[startPosition+1],\n      \"b\": this.identifyingImageData.data[startPosition+2],\n      \"opacity\": this.identifyingImageData.data[startPosition+3]\n    }\n    \n    let colorInt = this.colorStore.convertColorObjectToColorInt(color)\n    let colorString = this.colorStore.convertColorIntToRGBHexString(colorInt)\n\n    return colorString\n  }\n  \n  _getIndividualByIdentifyingColor(identifyingColor) {\n    let index = this.individualIndexByIdentifyingColor[identifyingColor]\n    return this._getIndividualByIndex(index)\n  }\n  \n  _getIndividualByIndex(index) {\n    let result\n    \n    this.data.forEach(individual => {\n      if (individual.index == index) {\n        result = individual\n      }\n    })\n    \n    return result\n  }\n  \n  _buildIdentifyingImageData() {\n    this._drawWithIdentifyingColors()\n    \n    const context = this.canvas.getContext(\"2d\")\n    let canvasDimensions = this._getCanvasSize()\n    this.identifyingImageData = context.getImageData(0, 0, canvasDimensions.width, canvasDimensions.height)\n    \n    this._draw()\n  }\n  \n  _isBackgroundColor(color) {\n    return color === \"#00000000\"\n  }\n  \n  _updateExtent() {\n    let extent = lively.getExtent(this.get(\"#canvas-widget-canvas-container\"))\n    if (extent.x == 0 && extent.y == 0) {\n      //canvas widget canvas container is not initialised yet\n      extent = lively.getExtent(this.container)\n      extent.x = extent.x * 0.65\n    }\n    \n    let oldCanvasExtent = {\n      \"x\": this.canvas.width,\n      \"y\": this.canvas.height,\n    }\n    \n    let newCanvasExtent = {\n      \"x\": extent.x - this.canvasPadding.left - this.canvasPadding.right,\n      \"y\": extent.y - this.canvasPadding.top - this.canvasPadding.bottom,\n    }\n    \n    this.scalesSVG\n      .attr(\"width\", extent.x)\n      .attr(\"height\", extent.y)\n    \n    d3.select(this.canvas)\n      .attr(\"width\", newCanvasExtent.x)\n      .attr(\"height\", newCanvasExtent.y)\n    \n    d3.select(this.drawCanvas)\n      .attr(\"width\", newCanvasExtent.x)\n      .attr(\"height\", newCanvasExtent.y)\n     \n    this._initializeAxes()\n    this._rescaleData(oldCanvasExtent, newCanvasExtent)\n    this._runCurrentActions()\n    \n    this._draw()\n  }\n  \n  _getCanvasSize() {\n    return {\"width\": this.canvas.width, \"height\": this.canvas.height}\n  }\n  \n  _runCurrentActions() {\n    Object.keys(this.currentActions).forEach(key => {\n      this._dispatchAction(this.currentActions[key])\n    })\n  }\n}"}